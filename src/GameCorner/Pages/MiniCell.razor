@using Microsoft.AspNetCore.Components.Web
@inject IJSRuntime JS

@if (IsBlock)
{
    <div class="mini-cell is-block"></div>
}
else
{
    <div class="mini-cell @(isFocused ? "is-active" : null) @(IsHighlighted ? "is-highlighted" : null)" @onclick="FocusInput" data-hl="@IsHighlighted">
        <input @ref="inputRef"
               class="mini-cell-input"
               type="text"
               maxlength="1"
               inputmode="@((DisableNativeKeyboard ? "none" : "latin"))"
               autocomplete="off"
               autocorrect="off"
               autocapitalize="characters"
               spellcheck="false"
               @bind-value="Text"
               @bind-value:event="oninput"
               @bind-value:after="OnTextChanged"
               @onfocus="OnFocus"
               @onblur="() => isFocused = false"
               @onkeydown="HandleKeyDown" />
    </div>
}

@code {
    private ElementReference inputRef;
    private bool isFocused;
    private string _text = "";
    private int _lastFocusKey = -1;
    private bool _shouldFocus;

    [Parameter] public bool IsBlock { get; set; }
    [Parameter] public bool IsHighlighted { get; set; }

    [Parameter] public char? Value { get; set; }
    [Parameter] public EventCallback<char?> ValueChanged { get; set; }
    [Parameter] public EventCallback<char?> OnInput { get; set; }

    [Parameter] public bool DisableNativeKeyboard { get; set; }

    // New: let parent decide which cell is “active” and when to (re)focus it
    [Parameter] public bool IsActive { get; set; }
    [Parameter] public int RequestFocusKey { get; set; }  // increment in parent to force focus
    [Parameter] public EventCallback<KeyboardEventArgs> OnKeyDownFromCell { get; set; }

    [Parameter] public bool AutoFocus { get; set; } = false;

    private async Task OnFocus(FocusEventArgs _)
    {
        isFocused = true;

        // If there is already a letter, select it so the next key overwrites it,
        // which will trigger 'input' (works on mobile).
        if (!string.IsNullOrEmpty(_text))
        {
            await JS.InvokeVoidAsync("mini.selectAll", inputRef);
        }
    }

    private string Text
    {
        get => _text;
        set
        {
            var s = (value ?? "").Trim();
            char? ch = null;

            if (s.Length > 0)
            {
                var last = s[^1];
                if (char.IsLetter(last))
                {
                    ch = char.ToUpperInvariant(last);
                    _text = ch.Value.ToString();
                }
                else
                {
                    _text = "";
                }
            }
            else
            {
                _text = "";
            }

            Value = ch;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!IsBlock)
        {
            if (firstRender && AutoFocus)
            {
                await inputRef.FocusAsync();
            }

            if (_shouldFocus)
            {
                _shouldFocus = false;
                await inputRef.FocusAsync();
            }
        }
    }

    protected override void OnParametersSet()
    {
        // programmatic changes
        var incoming = Value.HasValue ? Value.Value.ToString() : "";
        if (!string.Equals(_text, incoming, StringComparison.Ordinal))
            _text = incoming;

        if (!IsBlock && IsActive && RequestFocusKey != _lastFocusKey)
        {
            _lastFocusKey = RequestFocusKey;
            _shouldFocus = true;
        }
    }

    private async Task OnTextChanged()
    {
        if (ValueChanged.HasDelegate) await ValueChanged.InvokeAsync(Value);
        if (OnInput.HasDelegate) await OnInput.InvokeAsync(Value);
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (OnKeyDownFromCell.HasDelegate)
            await OnKeyDownFromCell.InvokeAsync(e);
    }

    private async Task FocusInput()
    {
        if(!IsBlock) await inputRef.FocusAsync();
    }
}