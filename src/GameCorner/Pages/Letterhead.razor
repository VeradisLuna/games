@page "/letterhead"
@page "/letterhead/{date}"
@page "/letterhead/special/{slug}"
@using GameCorner.Services
@using Hexicon.Letterhead
@using Microsoft.JSInterop
@inject IJSRuntime JS
@inject LetterheadVm Vm

<PageTitle>Letterhead</PageTitle>
<HeadContent>
    <meta property="og:title" content="Letterhead — Daily word-guessing game" />
    <meta property="og:description" content="Solve Letterhead by guessing the hidden word in, at most, six guesses. Each guess must be a valid word. After each guess, the colour of the tiles will change to show how close your guess was to the solution." />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="LunaMini.io" />
</HeadContent>

<div class="container">
    @if (string.IsNullOrWhiteSpace(Vm.SpecialSlug))
    {
        <GameCorner.Layout.DateNav BasePath="letterhead" MinDate="@(new DateOnly(2025, 11, 10))" />
    }
</div>

@if (!Vm.IsLoaded)
{
    <p>Loading puzzle...</p>
}
else
{
    <div class="container no-margin">
        <div class="lh-head">
            <h1 class="title letterhead-header">@(Vm.State == GameState.Playing ? "?????" : "")@(Vm.State == GameState.Won ? "👑 " + Vm.AnswerMasked : "")@(Vm.State == GameState.Lost ? Vm.AnswerMasked : "")</h1>
        </div>
    </div>

    <div id="lh-board" class="lh-board" tabindex="0" @onkeydown="OnKeyDown">
        <div class="lh-grid">
            @for (int r = 0; r < LetterheadVm.MaxRows; r++)
            {
                var rowIndex = r;
                <div class="lh-row @(RowClass(r))" id=@($"row-{r}")>
                    @for (int c = 0; c < LetterheadVm.WordLen; c++)
                    {
                        var colIndex = c;
                        var cell = Vm.Grid[r][c];
                        <div class="lh-cell @CellClass(cell) @((r == Vm.CurrentRow && c == Vm.CurrentCol && Vm.State == GameState.Playing) ? "is-active" : "")" id=@($"cell-{r}-{c}") @onclick="() => OnCellClick(rowIndex, colIndex)">
                            <span>@(cell.Ch)</span>
                        </div>
                    }
                </div>
            }
        </div>
    </div>

    <div class="lh-keys-wrapper">
        <LetterheadKeys OnKey="HandleKey" KeyStates="@Vm.KeyStates" Disabled=@(Vm.State != GameState.Playing) />
        @if(Vm.State != GameState.Playing)
        {
            <div class="lh-share-overlay">
                <button class="btn btn-primary" @onclick="SharePuzzle">@(copiedPuzzleToClipboard ? "Copied!" : "Share with friends")</button>
            </div>
        }
    </div>
}

@code {
    [Parameter] public string? date { get; set; }
    [Parameter] public string? slug { get; set; }
    private string? _lastDate;
    protected override async Task OnParametersSetAsync()
    {
        copiedPuzzleToClipboard = false;

        if (slug != null)
        {
            Vm.SpecialSlug = slug;
        }
        else
        {
            Vm.SpecialSlug = null;
        }

        if (date != _lastDate)           // only reload if the date changed
        {
            _lastDate = date;
            await Vm.InitAsync();         // provider will read new URL date
        }
    }

    protected override async Task OnInitializedAsync()
    {
        copiedPuzzleToClipboard = false;
        if (slug != null)
        {
            Vm.SpecialSlug = slug;
        }
        else
        {
            Vm.SpecialSlug = null;
        }

        await JS.InvokeVoidAsync("setWinterTheme", false);
        await JS.InvokeVoidAsync("miniConfetti.stopSnow");

        await Vm.InitAsync();
    }

    private bool _enabledFit;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Vm.IsLoaded)
        {
            if (!_enabledFit)
            {
                _enabledFit = true;
                await JS.InvokeVoidAsync("letterheadFit.enable");
            }
        }

        if (firstRender)
        {
            await JS.InvokeVoidAsync("miniLayout.enable");
        }
    }

    public async ValueTask DisposeAsync()
    {
        await JS.InvokeVoidAsync("letterheadFit.disable");
        await JS.InvokeVoidAsync("miniLayout.disable");
    }

    private Task HandleKey(string key)
    {
        switch (key)
        {
            case "ENTER":
                return OnEnter();
            case "BACKSPACE":
                Vm.Backspace();
                StateHasChanged();
                return Task.CompletedTask;
        }

        if(key.Length == 1)
        {
            Vm.TypeChar(key[0]);
            StateHasChanged();
            return Task.CompletedTask;
        }

        return Task.CompletedTask;
    }

    private string RowClass(int r) => r == Vm.CurrentRow && Vm.State == GameState.Playing ? "active" : string.Empty;

    private string CellClass(LetterheadVm.Cell cell) => cell.State switch
    {
        TileState.Correct => "correct",
        TileState.Present => "present",
        TileState.Absent => "absent",
        TileState.Pending => "pending",
        _ => string.Empty
    };

    private Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") return OnEnter();
        if (e.Key == "Backspace") { Vm.Backspace(); StateHasChanged(); return Task.CompletedTask; }
        if (e.Key?.Length == 1 && char.IsLetter(e.Key[0])) { Vm.TypeChar(e.Key[0]); StateHasChanged(); }
        return Task.CompletedTask;
    }

    private async Task OnEnter()
    {
        if (!Vm.CanSubmit) { await ShakeRow(Vm.CurrentRow); return; }
        var err = Vm.Submit();
        if (err is not null) { await ShakeRow(Vm.CurrentRow); return; }

        // reveal the row we just locked in (CurrentRow has moved unless win/lose)
        var revealIndex = Vm.State == GameState.Playing ? Vm.CurrentRow - 1 : Vm.CurrentRow;
        await RevealRow(revealIndex);

        if (Vm.State == GameState.Won)
        {
            await JS.InvokeVoidAsync("miniConfetti.poof", new { particles = 120, themeIndex = 4, zIndex = 10000 });
        }

        await Vm.SaveState();
        StateHasChanged();
    }

    private async Task OnCellClick(int row, int col)
    {
        Vm.SetActive(row, col);
        StateHasChanged();
        await JS.InvokeVoidAsync("lunaFocus.focus", "lh-board"); // same helper Mini uses
    }

    private ValueTask RevealRow(int r) => JS.InvokeVoidAsync("letterhead.revealRow", r);
    private ValueTask ShakeRow(int r) => JS.InvokeVoidAsync("letterhead.shakeRow", r);

    private bool copiedPuzzleToClipboard = false;
    public async Task SharePuzzle()
    {
        var text = Vm.BuildShareText();
        var shared = await JS.InvokeAsync<bool>("sharePuzzle.share", text, Vm.BuildShareTitle());
        if (!shared)
        {
            await JS.InvokeAsync<bool>("sharePuzzle.copy", text);
            copiedPuzzleToClipboard = true;
        }
    }
}