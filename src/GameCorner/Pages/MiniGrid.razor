@using Microsoft.AspNetCore.Components.Web
@page "/mini-grid"

<h3>Mini crossword (5×5)</h3>

<div class="mini-grid" tabindex="0">
    @for (int i = 0; i < 25; i++)
    {
        var idx = i;
        <div class="mini-grid-cellwrap" @onclick="@(() => Activate(idx))">
            <MiniCell Value="@cells[idx]"
                      ValueChanged="@(ch => SetCell(idx, ch))"
                      OnInput="@(ch => OnCellInput(idx, ch))"
                      OnKeyDownFromCell="@(e => OnCellKey(idx, e))"
                      IsActive="@(idx == activeIndex)"
                      RequestFocusKey="@focusKey" />
        </div>
    }
</div>

<p>Active: @(activeIndex) — Values: @BoardString</p>

@code {
    private char?[] cells = Enumerable.Repeat<char?>(null, 25).ToArray();
    private int activeIndex = 0;   // 0..24
    private int focusKey = 0;      // bump to force focus on active cell

    private string BoardString => new string(CellsToString());

    private void Activate(int idx)
    {
        activeIndex = idx;
        focusKey++;
    }

    private void SetCell(int idx, char? ch) => cells[idx] = ch;

    private void OnCellInput(int idx, char? ch)
    {
        // Type-to-advance (only when a valid letter was entered)
        if (ch.HasValue)
            MoveActive(NextIndex(idx));
        else
        {
            // If they cleared the cell, keep focus here.
            Activate(idx);
        }
    }

    private void OnCellKey(int idx, KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowLeft": MoveActive(Left(idx)); break;
            case "ArrowRight": MoveActive(Right(idx)); break;
            case "ArrowUp": MoveActive(Up(idx)); break;
            case "ArrowDown": MoveActive(Down(idx)); break;
            case "Backspace":
                if (cells[idx] is null)
                    MoveActive(PrevIndex(idx)); // back up if already empty
                break;
            case "Tab":
                MoveActive(NextIndex(idx));
                break;
            case "Enter":
                // Optional: flip direction later; for now treat as Next
                MoveActive(NextIndex(idx));
                break;
        }
    }

    // Also allow grid container to move focus with arrows when it has focus
    // private void HandleGridKey(KeyboardEventArgs e) => OnCellKey(activeIndex, e);

    private void MoveActive(int idx) => Activate(ClampToBoard(idx));

    private static int Row(int idx) => idx / 5;
    private static int Col(int idx) => idx % 5;

    private static int Left(int idx) => Row(idx) * 5 + Math.Max(0, Col(idx) - 1);
    private static int Right(int idx) => Row(idx) * 5 + Math.Min(4, Col(idx) + 1);
    private static int Up(int idx) => Math.Max(0, idx - 5);
    private static int Down(int idx) => Math.Min(24, idx + 5);

    private static int NextIndex(int idx)
    {
        var n = idx + 1;
        return n > 24 ? 24 : n;
    }

    private static int PrevIndex(int idx)
    {
        var p = idx - 1;
        return p < 0 ? 0 : p;
    }

    private static int ClampToBoard(int idx) => Math.Clamp(idx, 0, 24);

    private char[] CellsToString()
    {
        var arr = new char[25];
        for (int i = 0; i < 25; i++)
            arr[i] = cells[i] ?? '·';
        return arr;
    }
}