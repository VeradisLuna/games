@using Microsoft.AspNetCore.Components.Web
@page "/mini-grid"

<h3>Mini crossword (5×5)</h3>

<div class="mini-grid" tabindex="0">
    @for (int i = 0; i < 25; i++)
    {
        var idx = i;
        <div class="mini-grid-cellwrap" @onclick="@(() => Activate(idx))">
            <MiniCell IsBlock="@blocks[idx]"
                      Value="@cells[idx]"
                      ValueChanged="@(ch => SetCell(idx, ch))"
                      OnInput="@(ch => OnCellInput(idx, ch))"
                      OnKeyDownFromCell="@(e => OnCellKey(idx, e))"
                      IsActive="@(idx == activeIndex)"
                      RequestFocusKey="@focusKey" />
        </div>
    }
</div>

<p>Active: @(activeIndex) — Values: @BoardString</p>

@code {
    private char?[] cells = Enumerable.Repeat<char?>(null, 25).ToArray();
    private bool[] blocks = new bool[25];
    private int activeIndex = 0;
    private int focusKey = 0;

    private string BoardString => new string(Enumerable.Range(0, 25).Select(i => blocks[i] ? '#' : (cells[i] ?? '.')).ToArray());

    private void Activate(int idx)
    {
        if (idx < 0 || idx > 24) return;
        if (blocks[idx]) return;

        activeIndex = idx;
        focusKey++;
    }

    protected override void OnInitialized()
    {
        SetBlocks(2, 7, 11, 12, 13, 17, 22);
    }

    private void SetBlocks(params int[] idxs)
    {
        foreach (var i in idxs) blocks[i] = true;
    }

    private void SetCell(int idx, char? ch) => cells[idx] = ch;

    private void OnCellInput(int idx, char? ch)
    {
        if (ch.HasValue)
            MoveActive(NextRightOpen(idx));
        else
        {
            Activate(idx);
        }
    }

    private void OnCellKey(int idx, KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowLeft": MoveActive(NextLeftOpen(idx)); break;
            case "ArrowRight": MoveActive(NextRightOpen(idx)); break;
            case "ArrowUp": MoveActive(NextUpOpen(idx)); break;
            case "ArrowDown": MoveActive(NextDownOpen(idx)); break;
            case "Backspace":
                if (cells[idx] is null)
                {
                    MoveActive(NextLeftOpen(idx));
                }
                break;
            case "Tab":
                MoveActive(NextRightOpen(idx));
                break;
            case "Enter":
                MoveActive(NextRightOpen(idx));
                break;
        }
    }

    private void MoveActive(int idx) => Activate(ClampToBoard(idx));

    private static int Row(int idx) => idx / 5;
    private static int Col(int idx) => idx % 5;
    private static int Mod(int x, int m) => (x % m + m) % m;

    private static readonly int[] AcrossOrder =
        Enumerable.Range(0, 25).ToArray();

    private static readonly int[] DownOrder = BuildDownOrder();

    private static int[] BuildDownOrder()
    {
        var list = new List<int>(25);
        for (int c = 0; c < 5; c++)
            for (int r = 0; r < 5; r++)
                list.Add(r * 5 + c);
        return list.ToArray();
    }

    private int NextOpenInOrder(int idx, int[] order, bool forward)
    {
        int pos = Array.IndexOf(order, idx);
        if (pos < 0) return idx;

        for (int step = 1; step <= 24; step++)
        {
            int t = order[Mod(pos + (forward ? step : -step), 25)];
            if (!blocks[t]) return t;
        }
        return idx;
    }

    private int NextRightOpen(int idx) => NextOpenInOrder(idx, AcrossOrder, true);
    private int NextLeftOpen(int idx) => NextOpenInOrder(idx, AcrossOrder, false);
    private int NextDownOpen(int idx) => NextOpenInOrder(idx, DownOrder, true);
    private int NextUpOpen(int idx) => NextOpenInOrder(idx, DownOrder, false);

    private static int NextIndex(int idx)
    {
        var n = idx + 1;
        return n > 24 ? 24 : n;
    }

    private static int PrevIndex(int idx)
    {
        var p = idx - 1;
        return p < 0 ? 0 : p;
    }

    private static int ClampToBoard(int idx) => Math.Clamp(idx, 0, 24);
}