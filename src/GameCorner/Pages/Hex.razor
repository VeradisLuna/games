@page "/hexicon"
@inject GameCorner.ViewModels.HexiconVm Vm
@inject IJSRuntime JS

<PageTitle>Hexicon</PageTitle>

<div class="container">
    <h1>
        @Vm.PuzzleDate.ToString("dddd"):
        @if (Vm.Tagline is { Length: > 0 })
        {
            @Vm.Tagline
        }
        else
        {
            @(Vm.TitleRevealed? Vm.PangramTitle: "???")
        }
    </h1>

    <div class="score-area">
        <h2 class="rank-line @CurrentRank.css @( _pulse ? "pulse" : null )" aria-live="polite">
            @CurrentRank.label
        </h2>

        <p class="next-rank">@NextRankText</p>
    </div>

    <div class="row g-2 align-items-center mb-3 input-area">
        <div class="col-12 col-md">
            <input class="form-control" @bind="Vm.CurrentEntry" @onkeydown="HandleKeyDown" @oninput="HandleInput" autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false" inputmode="latin"
            placeholder="Type or tap letters..."/>
        </div>
        <div class="col-12 col-md-auto">
            <div class="d-flex gap-2 justify-content-md-end">
                <button class="btn btn-outline-secondary" @onclick="Vm.Backspace">⌫</button>
                <button class="btn btn-outline-secondary" @onclick="Vm.ClearEntry">Clear</button>
                <button class="btn btn-primary" @onclick="SubmitClicked" disabled="@(Vm.CanSubmit ? null : true)">Submit</button>
            </div>
        </div>
        <span class="floaty-wrap" aria-hidden="true">
            @if (_showFloaty)
            {
                <span class="floaty" @key="_floatyRunId">+@_lastDelta</span>
            }
        </span>
    </div>

    <div class="hex">
        <button class="cell required" @onclick="() => Vm.Append(Vm.Required)">
            @Vm.Required
        </button>

        @foreach (var c in Vm.Letters.Where(c => c != Vm.Required))
        {
            <button class="cell" @onclick="() => Vm.Append(c)">@c</button>
        }
    </div>

    <div class="bar">
        <button class="btn btn-outline-secondary" @onclick="Vm.Shuffle">Shuffle</button>
        <button class="btn btn-outline-danger" @onclick="OpenConfirm">Reset this puzzle</button>
    </div>

    @if (Vm.Themed)
    {
        <h4 class="mt-4">Found words (@Vm.Found.Count / @Vm.TotalWords)</h4>
    }
    else
    {
        <h4 class="mt-4">Found words (@Vm.Found.Count)</h4>
    }
    <div class="found-box">
        <ul class="found-list">
            @foreach (var w in Vm.Found.OrderBy(w => w.Length).ThenBy(w => w))
            {
                <li class="found-word @(Vm.IsPangram(w) ? "pangram" : null)">@w</li>
            }
        </ul>
    </div>

    @if (_confirmOpen)
    {
        <div class="hx-modal-backdrop" @onclick="CloseConfirm" />

        <div class="hx-modal" role="dialog" aria-modal="true" aria-labelledby="hx-reset-title" @onkeydown="HandleKeyDown" tabindex="0">
            <h3 id="hx-reset-title">Reset today's progress?</h3>
            <p>This will clear your found words and score for today. This cannot be undone!</p>

            <div class="hx-modal-actions">
                <button class="btn btn-outline-secondary" @onclick="CloseConfirm">Cancel</button>
                <button class="btn btn-danger" @onclick="ConfirmResetAsync">Reset</button>
            </div>
        </div>
    }
</div>

@code {
    protected override async Task OnInitializedAsync()
    {
        await Vm.InitAsync();
    }

    private int _lastLevelIndex = 0;
    private bool _pulse;

    // Tiny puzzles keep just the three "Hex—" ranks (by words found)
    private static readonly (int level, string name, string css)[] TinyTiers =
    {
        (1, "Hexemplary",   "rank-green"),
        (2, "Hextraordinary", "rank-blue"),
        (3, "Hexceptional", "rank-purple")
    };

    // Normal puzzles get milestones + the three "Hex—" ranks (by score ratio)
    private static readonly (double pct, string name, string css)[] BigTiers =
    {
        (0.13, "Warming up",  "rank-ash"),
        (0.26, "Solid",       "rank-ash"),
        (0.39, "Strong",      "rank-ash"),
        (0.52, "Sharp",       "rank-ash"),
        (0.66, "Hexemplary",  "rank-green"),
        (0.80, "Hextraordinary","rank-blue"),
        (0.90, "Hexceptional", "rank-purple")
    };


    private (string label, string css, int levelIndex) CurrentRank
    {
        get
        {
            if (TinyPuzzle())
            {
                int words = Vm.Found.Count;
                int neededForMax = Math.Min(3, Vm.TotalWords);
                int level = Math.Clamp(words, 0, neededForMax);

                if (level == 0) return ($"{Vm.Found.Count} word{(words == 1 ? "" : "s")}", "rank-default", 0);

                var tier = TinyTiers[level - 1];
                return ($"{tier.name}! {words} word{(words == 1 ? "" : "s")}", tier.css, level);
            }
            else
            {
                double pct = Vm.ScoreRatio;
                int idx = -1;
                for (int i = 0; i < BigTiers.Length; i++)
                    if (pct >= BigTiers[i].pct) idx = i;

                if (idx < 0) return ($"{Vm.Score} points", "rank-default", 0);

                var t = BigTiers[idx];
                return ($"{t.name}! {Vm.Score} points", t.css, idx + 1);
            }
        }
    }

    protected bool TinyPuzzle()
    {
        return Vm.TotalWords <= 5;
    }

    protected override void OnAfterRender(bool firstRender)
    {
        var cur = CurrentRank.levelIndex;
        if (cur > _lastLevelIndex)
        {
            _lastLevelIndex = cur;
            _ = TriggerPulse();
        }
        else
        {
            _lastLevelIndex = cur;
        }
    }

    private async Task TriggerPulse()
    {
        _pulse = true; StateHasChanged();
        await Task.Delay(900);
        _pulse = false; StateHasChanged();
    }

    private string ProgressWidth => $"{Math.Round(Math.Clamp(Vm.ScoreRatio, 0, 1) * 100)}%";

    private string NextRankText
    {
        get
        {
            if (TinyPuzzle()) return "";

            double pct = Vm.ScoreRatio;
            var next = BigTiers.FirstOrDefault(t => pct < t.pct);
            if (next == default) return "";

            int ptsNeeded = (int)Math.Ceiling(next.pct * Vm.TargetScore) - Vm.Score;
            return $"Next rank: {next.name} ({ptsNeeded} points to go)";
        }
    }

    private ElementReference _inputRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender) { try { await _inputRef.FocusAsync(); } catch { } }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        var key = e.Key ?? "";

        if (_confirmOpen && key == "Escape")
        {
            CloseConfirm();
            StateHasChanged();
            return;
        }

        if (key == "Enter")
        {
            await Vm.SubmitAsync();
            StateHasChanged();
            return;
        }

        if (key == "Escape")
        {
            Vm.ClearEntry();
            StateHasChanged();
            return;
        }

        if (key == " ")
        {
            Vm.Shuffle();
            StateHasChanged();
            return;
        }
    }

    private void HandleInput(ChangeEventArgs e)
    {
        var s = (e.Value?.ToString() ?? "");
        var allowed = Vm.Letters;
        Vm.CurrentEntry = new string(s.Where(ch => allowed.Contains(ch)).ToArray());
    }

    private async Task SubmitClicked()
    {
        var ok = await Vm.SubmitAsync();
        if (ok)
        {
            StateHasChanged(); // force refresh UI after persistence
        }
    }

    private bool _confirmOpen;
    private void OpenConfirm() => _confirmOpen = true;
    private void CloseConfirm() => _confirmOpen = false;

    private async Task ConfirmResetAsync()
    {
        await Vm.ResetTodayAsync();
        _confirmOpen = false;
        StateHasChanged();
    }

    private async Task ResetClicked()
    {
        var ok = await JS.InvokeAsync<bool>("confirm", "Reset today's progress? This cannot be undone!");
        if (ok)
        {
            await Vm.ResetTodayAsync();
            StateHasChanged(); // force the UI to update
        }
    }

    private int _lastDelta;
    private bool _showFloaty;
    private int _floatyRunId; // changes to restart CSS animation

    protected override void OnInitialized()
    {
        Vm.OnScored += HandleScored;
    }

    private async void HandleScored(int delta)
    {
        if (delta <= 0) return;
        _lastDelta = delta;
        _floatyRunId++;        // change key to re-trigger animation
        _showFloaty = false;   // reset
        StateHasChanged();

        // show on next tick so the CSS animation restarts cleanly
        await Task.Yield();
        _showFloaty = true;
        StateHasChanged();

        await Task.Delay(1500); // match CSS duration
        _showFloaty = false;
        StateHasChanged();
    }

    public void Dispose()
    {
        Vm.OnScored -= HandleScored;
    }
}