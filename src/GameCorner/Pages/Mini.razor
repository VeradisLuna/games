@page "/mini"
@page "/mini/{date}"
@using GameCorner.Services
@using Hexicon.Mini
@using Microsoft.JSInterop
@inject MiniCrosswordVm Vm
@inject IJSRuntime JS

<div class="container">
    <GameCorner.Layout.DateNav BasePath="mini" MinDate="@(new DateOnly(2025, 09, 09))" />
</div>
@if (!Vm.IsLoaded)
{
    <p>Loading puzzle...</p>
}
else
{
    var spanSet = CurrentSpanSet();
    <div class="container-xl">
        <div class="row g-4 justify-content-center align-items-start mini-layout-row">
            <div class="col-auto">
                <h1 class="title mini-header">@Vm.Title</h1>
                @* <p class="byline">by @Vm.Author — @Vm.PuzzleDate</p> *@
                @if (solved)
                {
                    @if (Vm.Revealed)
                    {
                        <div class="rank-line pulse">Revealed!</div>
                    }
                    else
                    {
                        <div class="rank-line rank-purple pulse">Correct!</div>
                    }
                }
                <div class="mini-board">
                    <div class="mini-grid" id="mini-grid">
                        @for (int r = 0; r < MiniCrosswordVm.Size; r++)
                        {
                            for (int c = 0; c < MiniCrosswordVm.Size; c++)
                            {
                                var idx = r * MiniCrosswordVm.Size + c;
                                var cell = Vm.Grid[idx];
                                var cellActive = spanSet.Contains(idx) ? "clue--active-entry" : "";
                                <div class="mini-grid-cellwrap @cellActive" @onclick="@(() => OnCellClick(idx))">
                                    @if (cell.IsBlock)
                                    {
                                        <MiniCell IsBlock="true" />
                                    }
                                    else
                                    {
                                        <div class="cluenumber">@cell.Number</div>
                                        <MiniCell Value="@(cell.Entry)"
                                                    ValueChanged="@(ch => Vm.SetEntry(idx, ch))"
                                                    OnInput="@(ch => OnCellInput(idx, ch))"
                                                    OnKeyDownFromCell="@(e => OnCellKey(idx, e))"
                                                    IsActive="@(idx == activeIndex)"
                                                    RequestFocusKey="@focusKey"
                                                    DisableNativeKeyboard="useOnscreenKeys"/>
                                    }
                                </div>
                            }
                        }
                    </div>
                </div>
                <div class="current-clue-spacer d-lg-none"></div>
            </div>
            @{
                var curInfo = CurrentClueInfo();
            }
            <div class="col-12 col-lg-7">
                <div class="current-clue-bar d-lg-none">
                    <div class="d-flex align-items-center justify-content-between gap-2">
                        <button type="button" class="btn btn-outline-secondary btn-sm"
                                @onclick="PrevClue" aria-label="Previous clue">
                            ◀︎
                        </button>

                        <div class="flex-grow-1 text-center">
                            @if (curInfo is not null)
                            {
                                <span class="fw-bold me-1">@($"{curInfo.Value.number}{(curInfo.Value.isAcross ? "A" : "D")}.")</span>
                                <span>@curInfo.Value.text</span>
                            }
                        </div>

                        <button type="button" class="btn btn-outline-secondary btn-sm"
                                @onclick="NextClue" aria-label="Next clue">
                            ▶︎
                        </button>
                    </div>
                </div>
                <div class="d-none d-lg-block">
                    <div class="row row-cols-1 row-cols-lg-2 g-3">
                        <section class="col">
                            <h5 class="mb-2">Across</h5>
                            <ol class="list-group list-group-flush clue-pane">
                                @foreach (var a in Vm.Across)
                                {
                                    var active = ClueClass(a, true) == "clue--active";
                                    <li class="list-group-item py-2 px-2 rounded-3 @(active ? "active" : "")" role="button" tabindex="0" @onclick="() => JumpToClue(a)">
                                        <span class="clue-num me-2 d-none d-lg-inline">@($"{a.Number}.")</span>
                                        @a.Text
                                    </li>
                                }
                            </ol>
                        </section>

                        <section class="col">
                            <h5 class="mb-2">Down</h5>
                            <ol class="list-group list-group-flush clue-pane">
                                @foreach (var d in Vm.Down)
                                {
                                    var active = ClueClass(d, false) == "clue--active";
                                    <li class="list-group-item py-2 px-2 rounded-3 @(active ? "active" : "")" role="button" tabindex="0" @onclick="() => JumpToClue(d)">
                                        <span class="clue-num me-2 d-none d-lg-inline">@($"{d.Number}.")</span>
                                        @d.Text
                                    </li>
                                }
                            </ol>
                        </section>
                    </div>
                </div>
            </div>
            @if (useOnscreenKeys)
            {
                <MiniKeys DownMode="downMode"
                          OnLetter="@(c => { Vm.SetEntry(activeIndex, c); OnCellInput(activeIndex, c); AfterEntryChanged(); })"
                          OnBackspace="@( () => { if (Vm.GetEntry(activeIndex) is null) Activate(nav.PrevOnBackspace(downMode, activeIndex).To); Vm.SetEntry(activeIndex, null); AfterEntryChanged(); })"
                          OnNextClue="NextClue"
                          OnPrevClue="PrevClue"
                          OnTab="@( () => { var res = nav.NextAfterInput(downMode, activeIndex); if (res.Wrapped) downMode = !downMode; Activate(res.To); })"
                OnToggleMode="@( () => { downMode = !downMode; focusKey++; })" />
            }
            else
            {
                <button type="button"
                        class="btn btn-outline-secondary btn-sm show-keys-btn"
                        @onclick="ShowOnscreenKeyboard">
                    Show on-screen keyboard
                </button>
            }
        </div>
    </div>
}

@code {
    bool useOnscreenKeys;
    bool _lastUseOnscreenKeys;
    bool mobileLikely;

    [Parameter] public string? date { get; set; }
    private string? _lastDate;
    protected override async Task OnParametersSetAsync()
    {
        if (date != _lastDate)           // only reload if the date changed
        {
            _lastDate = date;
            await Vm.InitAsync();         // provider will read new URL date
        }
    }

    private DotNetObjectReference<Mini>? selfRef;

    private MiniNavigator nav;
    private bool downMode = false;

    private int activeIndex = 0;
    private int focusKey = 0;

    protected override async Task OnInitializedAsync()
    {
        await Vm.InitAsync();

        nav = new MiniNavigator(MiniCrosswordVm.Size, idx => Vm.IsBlock(idx));

        // pick first non-block as start
        for (int i = 0; i < MiniCrosswordVm.Cells; i++)
            if (!Vm.IsBlock(i)) { activeIndex = i; break; }
        focusKey++;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(Vm.IsLoaded && selfRef is null)
        {
            selfRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("miniTabs.enable", "mini-grid", selfRef);
            await JS.InvokeVoidAsync("miniDevice.subscribe", selfRef);
        }

        if (firstRender)
        {
            await JS.InvokeVoidAsync("miniLayout.enable");
            await JS.InvokeVoidAsync("miniClueBar.enable");
            await JS.InvokeVoidAsync("miniFit.enable");
        }

        if (useOnscreenKeys && !_lastUseOnscreenKeys)
        {
            _lastUseOnscreenKeys = useOnscreenKeys;
            await JS.InvokeVoidAsync("miniLayout.refresh");
        }
        else
        {
            _lastUseOnscreenKeys = useOnscreenKeys;
        }
    }

    [JSInvokable]
    public Task SetOnscreenKeys(bool enable)
    {
        mobileLikely = enable;

        if (mobileLikely && !useOnscreenKeys)
        {
            ShowOnscreenKeyboard();
        }

        StateHasChanged();
        return Task.CompletedTask;
    }

    private void ShowOnscreenKeyboard()
    {
        useOnscreenKeys = true;
        focusKey++;
        _ = JS.InvokeVoidAsync("miniMobile.ensureInView");
        _ = JS.InvokeVoidAsync("miniLayout.refresh");
        StateHasChanged();
    }


    [JSInvokable]
    public Task OnTab(bool shift)
    {
        // Shift+Tab goes backward in the current mode; Tab goes forward
        var res = shift
            ? nav.PrevOnBackspace(downMode, activeIndex)
            : nav.NextAfterInput(downMode, activeIndex);

        if (res.Wrapped)
            downMode = !downMode;

        Activate(res.To);
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        if(selfRef is not null)
        {
            await JS.InvokeVoidAsync("miniTabs.disable", "mini-grid");
            await JS.InvokeVoidAsync("miniDevice.unsubscribe");
            selfRef.Dispose();
        }

        await JS.InvokeVoidAsync("miniFit.disable");
        await JS.InvokeVoidAsync("miniClueBar.disable");
        await JS.InvokeVoidAsync("miniLayout.disable");
    }

    private void OnCellInput(int idx, char? ch)
    {
        if (!ch.HasValue)
        {
            Activate(idx);
            AfterEntryChanged();
            return;
        }

        var res = nav.NextAfterInput(downMode, idx);
        if (res.Wrapped) downMode = !downMode;
        Activate(res.To);
        AfterEntryChanged();
    }

    private void OnCellKey(int idx, KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowLeft":
                {
                    downMode = false;
                    var res = nav.NextLeftOpen(idx);
                    Activate(res.To);
                    break;
                }
            case "ArrowRight":
                {
                    downMode = false;
                    var res = nav.NextRightOpen(idx);
                    Activate(res.To);
                    break;
                }
            case "ArrowUp":
                {
                    downMode = true;
                    var res = nav.NextUpOpen(idx);
                    Activate(res.To);
                    break;
                }
            case "ArrowDown":
                {
                    downMode = true;
                    var res = nav.NextDownOpen(idx);
                    Activate(res.To);
                    break;
                }
            case "Backspace":
                {
                    if (Vm.GetEntry(idx) is null)
                    {
                        var res = nav.PrevOnBackspace(downMode, idx);
                        Activate(res.To);
                        AfterEntryChanged();
                    }
                    break;
                }
        }
    }

    private void Activate(int idx)
    {
        activeIndex = idx;
        focusKey++;

        _ = JS.InvokeVoidAsync("miniFit.fit");
    }

    private void OnCellClick(int idx)
    {
        if (idx == activeIndex)
        {
            downMode = !downMode;
            focusKey++;
        }
        else
        {
            Activate(idx);
        }
    }

    // Compute span start for current mode
    private int FindSpanStartIndex(int idx, bool isDown)
    {
        int size = MiniCrosswordVm.Size;
        int r = idx / size, c = idx % size;

        if (isDown)
        {
            while (r > 0 && !Vm.IsBlock((r - 1) * size + c)) r--;
            return r * size + c;
        }
        else
        {
            while (c > 0 && !Vm.IsBlock(r * size + (c - 1))) c--;
            return r * size + c;
        }
    }

    // Enumerate indices in the span from a start index (inclusive)
    private IEnumerable<int> EnumerateSpanIndices(int startIdx, bool isDown)
    {
        int size = MiniCrosswordVm.Size;
        int r = startIdx / size, c = startIdx % size;

        if (isDown)
        {
            for (int rr = r; rr < size; rr++)
            {
                int i = rr * size + c;
                if (Vm.IsBlock(i)) yield break;
                yield return i;
            }
        }
        else
        {
            for (int cc = c; cc < size; cc++)
            {
                int i = r * size + cc;
                if (Vm.IsBlock(i)) yield break;
                yield return i;
            }
        }
    }

    // Convenience: current clue identity (number + side)
    private (int number, bool isAcross)? CurrentClue()
    {
        if (!Vm.IsLoaded) return null;

        int start = FindSpanStartIndex(activeIndex, downMode);
        var num = Vm.Grid[start].Number;
        if (num is null) return null; // should not happen, but be safe

        return (num.Value, isAcross: !downMode);
    }

    // Return CSS class for a clue item
    private string ClueClass(Hexicon.Mini.MiniCrosswordVm.Clue clue, bool forAcrossList)
    {
        var cur = CurrentClue();
        if (cur is null) return "";
        return (cur.Value.number == clue.Number && cur.Value.isAcross == forAcrossList) ? "clue--active" : "";
    }

    // For optional cell highlighting
    private HashSet<int> CurrentSpanSet()
    {
        var set = new HashSet<int>();
        if (!Vm.IsLoaded) return set;
        int start = FindSpanStartIndex(activeIndex, downMode);
        foreach (var i in EnumerateSpanIndices(start, downMode)) set.Add(i);
        return set;
    }

    private void JumpToClue(MiniCrosswordVm.Clue clue)
    {
        var cur = CurrentClue();
        if (cur is not null && cur.Value.number == clue.Number && cur.Value.isAcross == clue.IsAcross)
            return;

        downMode = !clue.IsAcross;
        int idx = clue.Row * MiniCrosswordVm.Size + clue.Col;
        Activate(idx);
    }

    private static int IndexOfClueByNumber(IReadOnlyList<Hexicon.Mini.MiniCrosswordVm.Clue> list, int number)
    {
        for (int i = 0; i < list.Count; i++)
            if (list[i].Number == number) return i;
        return -1;
    }

    private (int number, bool isAcross, string text)? CurrentClueInfo()
    {
        var cur = CurrentClue();
        if (cur is null) return null;

        var (num, isAcross) = cur.Value;
        var list = isAcross ? Vm.Across : Vm.Down;
        var i = IndexOfClueByNumber(list, num);
        if (i < 0) return null;

        return (num, isAcross, list[i].Text);
    }

    private void NextClue()
    {
        var cur = CurrentClue();
        if (cur is null) return;

        var across = Vm.Across;
        var down = Vm.Down;
        int total = across.Count + down.Count;
        if (total == 0) return;

        // find current index in the combined Across-then-Down order
        int combinedIndex =
            cur.Value.isAcross
            ? IndexOfClueByNumber(across, cur.Value.number)
            : across.Count + IndexOfClueByNumber(down, cur.Value.number);

        if (combinedIndex < 0) combinedIndex = 0;

        int next = (combinedIndex + 1) % total;

        // map back to the actual clue object
        var target = next < across.Count ? across[next]
                                         : down[next - across.Count];

        JumpToClue(target);
    }

    private void PrevClue()
    {
        var cur = CurrentClue();
        if (cur is null) return;

        var across = Vm.Across;
        var down = Vm.Down;
        int total = across.Count + down.Count;
        if (total == 0) return;

        int combinedIndex =
            cur.Value.isAcross
            ? IndexOfClueByNumber(across, cur.Value.number)
            : across.Count + IndexOfClueByNumber(down, cur.Value.number);

        if (combinedIndex < 0) combinedIndex = 0;

        int prev = (combinedIndex - 1 + total) % total;

        var target = prev < across.Count ? across[prev]
                                         : down[prev - across.Count];

        JumpToClue(target);
    }

    private bool solved;
    private void AfterEntryChanged()
    {
        if(!solved && Vm.Solved)
        {
            solved = true;
        }
        else if (solved && !Vm.Solved)
        {
            solved = false;
        }
        StateHasChanged();
    }
}