@page "/mini"
@page "/mini/{date}"
@page "/mini/special/{slug}"
@using GameCorner.Services
@using Hexicon.Mini
@using Microsoft.JSInterop
@inject MiniCrosswordVm Vm
@inject IJSRuntime JS

<PageTitle>Luna Mini</PageTitle>
<HeadContent>
    <meta property="og:title" content="Luna Mini — Daily mini crossword" />
    <meta property="og:description" content="New 5x5 themed crossword to play every day! Can you solve Luna Mini?" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="LunaMini.io" />
</HeadContent>

@if (string.IsNullOrWhiteSpace(Vm.SpecialSlug))
{
    <GameCorner.Layout.DateNav BasePath="mini" MinDate="@(new DateOnly(2025, 09, 22))" />
}
@if (!Vm.IsLoaded)
{
    <p>Loading puzzle...</p>
}
else
{
    var spanSet = CurrentSpanSet();
    <div class="container-xl">
        <div class="row g-4 justify-content-center align-items-start mini-layout-row">
            <div class="col-auto">
                <h1 class="title mini-header">@Vm.Title @((Vm.Solved && !Vm.Revealed) ? "👑"@* + Elapsed.ToString(@"mm\:ss")*@ : "")</h1>
                <div class="mini-board">
                    <div class="mini-grid" id="mini-grid">
                        @for (int r = 0; r < MiniCrosswordVm.Size; r++)
                        {
                            for (int c = 0; c < MiniCrosswordVm.Size; c++)
                            {
                                var idx = r * MiniCrosswordVm.Size + c;
                                var cell = Vm.Grid[idx];
                                var cellActive = spanSet.Contains(idx) ? "clue--active-entry" : "";
                                <div class="mini-grid-cellwrap @cellActive" @onclick="@(() => OnCellClick(idx))">
                                    @if (cell.IsBlock)
                                    {
                                        <MiniCell IsBlock="true" />
                                    }
                                    else
                                    {
                                        <div class="cluenumber">@cell.Number</div>
                                        <MiniCell Value="@(cell.Entry)"
                                                    ValueChanged="@(ch => Vm.SetEntry(idx, ch))"
                                                    OnInput="@(ch => OnCellInput(idx, ch))"
                                                    OnKeyDownFromCell="@(e => OnCellKey(idx, e))"
                                                    IsActive="@(idx == activeIndex)"
                                                    RequestFocusKey="@focusKey"
                                                    DisableNativeKeyboard="useOnscreenKeys"
                                                    IsHighlighted="@cell.IsHighlighted"
                                                    HighlightType="@cell.HighlightType"
                                                    IsCorrectUI="@(cell.Mark == CheckMark.Correct)"/>
                                    }
                                </div>
                            }
                        }
                    </div>
                </div>
                <div class="current-clue-spacer d-lg-none"></div>
            </div>
            @{
                var curInfo = CurrentClueInfo();
            }
            <div class="col-12 col-lg-7">
                <div class="current-clue-bar d-lg-none">
                    <div class="d-flex align-items-center justify-content-between gap-2">
                        <button type="button" class="btn btn-outline-secondary btn-sm"
                                @onclick="PrevClue" aria-label="Previous clue">
                            ◀︎
                        </button>

                        <div class="flex-grow-1 text-center">
                            @if (curInfo is not null)
                            {
                                <span class="fw-bold me-1">@($"{curInfo.Value.number}{(curInfo.Value.isAcross ? "A" : "D")}.")</span>
                                <span>@curInfo.Value.text</span>
                            }
                        </div>

                        <button type="button" class="btn btn-outline-secondary btn-sm"
                                @onclick="NextClue" aria-label="Next clue">
                            ▶︎
                        </button>
                    </div>
                </div>
                <div class="d-none d-lg-block">
                    <div class="row row-cols-1 row-cols-lg-2 g-3">
                        <section class="col">
                            <h5 class="mb-2">Across</h5>
                            <ol class="list-group list-group-flush clue-pane">
                                @foreach (var a in Vm.Across)
                                {
                                    var active = ClueClass(a, true) == "clue--active";
                                    <li class="list-group-item py-2 px-2 rounded-3 @(active ? "active" : "")" role="button" tabindex="0" @onclick="() => JumpToClue(a)">
                                        <span class="clue-num me-2 d-none d-lg-inline">@($"{a.Number}.")</span>
                                        @a.Text
                                    </li>
                                }
                            </ol>
                        </section>

                        <section class="col">
                            <h5 class="mb-2">Down</h5>
                            <ol class="list-group list-group-flush clue-pane">
                                @foreach (var d in Vm.Down)
                                {
                                    var active = ClueClass(d, false) == "clue--active";
                                    <li class="list-group-item py-2 px-2 rounded-3 @(active ? "active" : "")" role="button" tabindex="0" @onclick="() => JumpToClue(d)">
                                        <span class="clue-num me-2 d-none d-lg-inline">@($"{d.Number}.")</span>
                                        @d.Text
                                    </li>
                                }
                            </ol>
                        </section>
                    </div>
                </div>
            </div>
            @if (useOnscreenKeys)
            {
                <div class="mini-keys-wrapper">
                    <MiniKeys DownMode="downMode"
                              Disabled=@(Vm.Solved)
                              OnLetter="@(c => { Vm.SetEntry(activeIndex, c); OnCellInput(activeIndex, c); AfterEntryChanged(); })"
                              OnBackspace="@( () => { if (Vm.GetEntry(activeIndex) is null) Activate(nav.PrevOnBackspace(downMode, activeIndex).To); Vm.SetEntry(activeIndex, null); AfterEntryChanged(); })"
                              OnNextClue="NextClue"
                              OnPrevClue="PrevClue"
                              OnTab="@( () => { var res = nav.NextAfterInput(downMode, activeIndex); if (res.Wrapped) downMode = !downMode; Activate(res.To); })"
                              OnToggleMode="@( () => { downMode = !downMode; focusKey++; })"
                              OnCheckAll="OnCheckAll" />
                    @if (Vm.Solved)
                    {
                        <div class="mini-share-overlay">
                            <button class="btn btn-primary" @onclick="SharePuzzle">@(copiedPuzzleToClipboard ? "Copied!" : "Share with friends")</button>
                        </div>
                    }
                </div>
            }
            else
            {
                @if (Vm.Solved)
                {
                    <button class="btn btn-primary mini-share-button" @onclick="SharePuzzle">@(copiedPuzzleToClipboard ? "Copied!" : "Share with friends")</button>
                }
                else
                {
                    <button type="button"
                            class="btn btn-outline-secondary btn-sm show-keys-btn"
                            @onclick="ShowOnscreenKeyboard">
                        Show on-screen keyboard
                    </button>
                }
            }
        </div>
    </div>
}

@code {
    bool useOnscreenKeys;
    bool _lastUseOnscreenKeys;
    bool mobileLikely;

    [Parameter] public string? date { get; set; }
    private string? _lastDate;

    [Parameter] public string? slug { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        copiedPuzzleToClipboard = false;

        if (slug != null)
        {
            Vm.SpecialSlug = slug;
        }
        else
        {
            Vm.SpecialSlug = null;
        }

        if (date != _lastDate)           // only reload if the date changed
        {
            _lastDate = date;
            await Vm.InitAsync();         // provider will read new URL date
        }
    }

    private DotNetObjectReference<Mini>? selfRef;

    private MiniNavigator nav;
    private bool downMode = false;

    private int activeIndex = 0;
    private int focusKey = 0;

    protected override async Task OnInitializedAsync()
    {
        copiedPuzzleToClipboard = false;

        if (slug != null)
        {
            Vm.SpecialSlug = slug;
        }
        else
        {
            Vm.SpecialSlug = null;
        }

        await Vm.InitAsync();

        nav = new MiniNavigator(MiniCrosswordVm.Size, idx => Vm.IsBlock(idx));

        // pick first non-block as start
        for (int i = 0; i < MiniCrosswordVm.Cells; i++)
            if (!Vm.IsBlock(i)) { activeIndex = i; break; }
        focusKey++;
    }

    private System.Timers.Timer? _timer;
    private DateTime _startTime;
    public TimeSpan Elapsed { get; private set; }
    public bool IsRunning { get; private set; }

    private int _tenSecondLoop = 0;
    private bool _saving = false;
    private bool _enabledFit;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(Vm.IsLoaded && selfRef is null)
        {
            selfRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("miniTabs.enable", "mini-grid", selfRef);
            await JS.InvokeVoidAsync("miniDevice.subscribe", selfRef);

            if (!_enabledFit)
            {
                _enabledFit = true;
                await JS.InvokeVoidAsync("miniFit.enable");
            }
        }

        if (firstRender)
        {
            await JS.InvokeVoidAsync("miniLayout.enable");
            await JS.InvokeVoidAsync("miniClueBar.enable");

            _startTime = DateTime.UtcNow;
            Elapsed = TimeSpan.Zero;
            IsRunning = true;

            _timer = new System.Timers.Timer(1000) { AutoReset = true };
            _timer.Elapsed += async (_, __) =>
            {
                await InvokeAsync(async () =>
                {
                    _tenSecondLoop++;
                    Elapsed = DateTime.UtcNow - _startTime;

                    if (_tenSecondLoop >= 10 && !_saving && !Vm.Solved && !Vm.Revealed)
                    {
                        _tenSecondLoop = 0;
                        _saving = true;
                        try
                        {
                            // Vm.ElapsedMs = (long)Elapsed.TotalMilliseconds;
                            await Vm.SaveState();
                        }
                        finally { _saving = false; }
                    }

                    StateHasChanged();
                });
            };
            _timer.Start();
        }

        if (useOnscreenKeys && !_lastUseOnscreenKeys)
        {
            _lastUseOnscreenKeys = useOnscreenKeys;
            await JS.InvokeVoidAsync("miniLayout.refresh");
        }
        else
        {
            _lastUseOnscreenKeys = useOnscreenKeys;
        }
    }

    private void StopTimer()
    {
        if(_timer != null)
        {
            _timer.Stop();
            _timer.Dispose();
            _timer = null;
        }
        IsRunning = false;
    }

    [JSInvokable]
    public Task SetOnscreenKeys(bool enable)
    {
        mobileLikely = enable;

        if (mobileLikely && !useOnscreenKeys)
        {
            ShowOnscreenKeyboard();
        }

        StateHasChanged();
        return Task.CompletedTask;
    }

    private void ShowOnscreenKeyboard()
    {
        useOnscreenKeys = true;
        focusKey++;
        _ = JS.InvokeVoidAsync("miniMobile.ensureInView");
        _ = JS.InvokeVoidAsync("miniLayout.refresh");
        StateHasChanged();
    }


    [JSInvokable]
    public Task OnTab(bool shift)
    {
        // Shift+Tab goes backward in the current mode; Tab goes forward
        var res = shift
            ? nav.PrevOnBackspace(downMode, activeIndex)
            : nav.NextAfterInput(downMode, activeIndex);

        if (res.Wrapped)
            downMode = !downMode;

        Activate(res.To);
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        if(selfRef is not null)
        {
            await JS.InvokeVoidAsync("miniTabs.disable", "mini-grid");
            await JS.InvokeVoidAsync("miniDevice.unsubscribe");
            selfRef.Dispose();
        }

        await JS.InvokeVoidAsync("miniFit.disable");
        await JS.InvokeVoidAsync("miniClueBar.disable");
        await JS.InvokeVoidAsync("miniLayout.disable");
    }

    private void OnCellInput(int idx, char? ch)
    {
        if (!ch.HasValue)
        {
            Activate(idx);
            AfterEntryChanged();
            return;
        }

        var res = nav.NextAfterInput(downMode, idx);
        if (res.Wrapped) downMode = !downMode;
        Activate(res.To);
        AfterEntryChanged();
    }

    private void OnCellKey(int idx, KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowLeft":
                {
                    downMode = false;
                    var res = nav.NextLeftOpen(idx);
                    Activate(res.To);
                    break;
                }
            case "ArrowRight":
                {
                    downMode = false;
                    var res = nav.NextRightOpen(idx);
                    Activate(res.To);
                    break;
                }
            case "ArrowUp":
                {
                    downMode = true;
                    var res = nav.NextUpOpen(idx);
                    Activate(res.To);
                    break;
                }
            case "ArrowDown":
                {
                    downMode = true;
                    var res = nav.NextDownOpen(idx);
                    Activate(res.To);
                    break;
                }
            case "Backspace":
                {
                    if (Vm.GetEntry(idx) is null)
                    {
                        var res = nav.PrevOnBackspace(downMode, idx);
                        Activate(res.To);
                        AfterEntryChanged();
                    }
                    break;
                }
        }
    }

    private void Activate(int idx)
    {
        activeIndex = idx;
        focusKey++;

        _ = JS.InvokeVoidAsync("miniFit.fit");
    }

    private void OnCellClick(int idx)
    {
        if (idx == activeIndex)
        {
            downMode = !downMode;
            focusKey++;
        }
        else
        {
            Activate(idx);
        }
    }

    // Compute span start for current mode
    private int FindSpanStartIndex(int idx, bool isDown)
    {
        int size = MiniCrosswordVm.Size;
        int r = idx / size, c = idx % size;

        if (isDown)
        {
            while (r > 0 && !Vm.IsBlock((r - 1) * size + c)) r--;
            return r * size + c;
        }
        else
        {
            while (c > 0 && !Vm.IsBlock(r * size + (c - 1))) c--;
            return r * size + c;
        }
    }

    // Enumerate indices in the span from a start index (inclusive)
    private IEnumerable<int> EnumerateSpanIndices(int startIdx, bool isDown)
    {
        int size = MiniCrosswordVm.Size;
        int r = startIdx / size, c = startIdx % size;

        if (isDown)
        {
            for (int rr = r; rr < size; rr++)
            {
                int i = rr * size + c;
                if (Vm.IsBlock(i)) yield break;
                yield return i;
            }
        }
        else
        {
            for (int cc = c; cc < size; cc++)
            {
                int i = r * size + cc;
                if (Vm.IsBlock(i)) yield break;
                yield return i;
            }
        }
    }

    // Convenience: current clue identity (number + side)
    private (int number, bool isAcross)? CurrentClue()
    {
        if (!Vm.IsLoaded) return null;

        int start = FindSpanStartIndex(activeIndex, downMode);
        var num = Vm.Grid[start].Number;
        if (num is null) return null; // should not happen, but be safe

        return (num.Value, isAcross: !downMode);
    }

    // Return CSS class for a clue item
    private string ClueClass(Hexicon.Mini.MiniCrosswordVm.Clue clue, bool forAcrossList)
    {
        var cur = CurrentClue();
        if (cur is null) return "";
        return (cur.Value.number == clue.Number && cur.Value.isAcross == forAcrossList) ? "clue--active" : "";
    }

    // For optional cell highlighting
    private HashSet<int> CurrentSpanSet()
    {
        var set = new HashSet<int>();
        if (!Vm.IsLoaded) return set;
        int start = FindSpanStartIndex(activeIndex, downMode);
        foreach (var i in EnumerateSpanIndices(start, downMode)) set.Add(i);
        return set;
    }

    private void JumpToClue(MiniCrosswordVm.Clue clue)
    {
        var cur = CurrentClue();
        if (cur is not null && cur.Value.number == clue.Number && cur.Value.isAcross == clue.IsAcross)
            return;

        downMode = !clue.IsAcross;
        int idx = clue.Row * MiniCrosswordVm.Size + clue.Col;
        Activate(idx);
    }

    private static int IndexOfClueByNumber(IReadOnlyList<Hexicon.Mini.MiniCrosswordVm.Clue> list, int number)
    {
        for (int i = 0; i < list.Count; i++)
            if (list[i].Number == number) return i;
        return -1;
    }

    private (int number, bool isAcross, string text)? CurrentClueInfo()
    {
        var cur = CurrentClue();
        if (cur is null) return null;

        var (num, isAcross) = cur.Value;
        var list = isAcross ? Vm.Across : Vm.Down;
        var i = IndexOfClueByNumber(list, num);
        if (i < 0) return null;

        return (num, isAcross, list[i].Text);
    }

    private void NextClue()
    {
        var cur = CurrentClue();
        if (cur is null) return;

        var across = Vm.Across;
        var down = Vm.Down;
        int total = across.Count + down.Count;
        if (total == 0) return;

        // find current index in the combined Across-then-Down order
        int combinedIndex =
            cur.Value.isAcross
            ? IndexOfClueByNumber(across, cur.Value.number)
            : across.Count + IndexOfClueByNumber(down, cur.Value.number);

        if (combinedIndex < 0) combinedIndex = 0;

        int next = (combinedIndex + 1) % total;

        // map back to the actual clue object
        var target = next < across.Count ? across[next]
                                         : down[next - across.Count];

        JumpToClue(target);
    }

    private void PrevClue()
    {
        var cur = CurrentClue();
        if (cur is null) return;

        var across = Vm.Across;
        var down = Vm.Down;
        int total = across.Count + down.Count;
        if (total == 0) return;

        int combinedIndex =
            cur.Value.isAcross
            ? IndexOfClueByNumber(across, cur.Value.number)
            : across.Count + IndexOfClueByNumber(down, cur.Value.number);

        if (combinedIndex < 0) combinedIndex = 0;

        int prev = (combinedIndex - 1 + total) % total;

        var target = prev < across.Count ? across[prev]
                                         : down[prev - across.Count];

        JumpToClue(target);
    }

    private bool solved;
    private void AfterEntryChanged()
    {
        if(!solved && Vm.Solved)
        {
            solved = true;
            StopTimer();
            //Vm.ElapsedMs = (long)Elapsed.TotalMilliseconds;
            _ = Vm.SaveState();
            OnCheckAll();

            JS.InvokeVoidAsync("miniConfetti.poof", new
            {
                particles = 120,
                themeIndex = 0,
                zIndex = 10000
            });
        }
        else if (solved && !Vm.Solved)
        {
            solved = false;
        }
        StateHasChanged();
    }

    private void OnCheckAll()
    {
        Vm.CheckAllCells();
        StateHasChanged();
    }

    private bool copiedPuzzleToClipboard = false;
    public async Task SharePuzzle()
    {
        var text = Vm.BuildShareText();
        var shared = await JS.InvokeAsync<bool>("sharePuzzle.share", text, Vm.BuildShareTitle());
        if (!shared)
        {
            await JS.InvokeAsync<bool>("sharePuzzle.copy", text);
            copiedPuzzleToClipboard = true;
        }
    }
}